// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package yml

import (
	"sync"
)

// Ensure, that WriterMock does implement Writer.
// If this is not the case, regenerate this file with moq.
var _ Writer = &WriterMock{}

// WriterMock is a mock implementation of Writer.
//
//	func TestSomethingThatUsesWriter(t *testing.T) {
//
//		// make and configure a mocked Writer
//		mockedWriter := &WriterMock{
//			WriteFileFunc: func(file *File) error {
//				panic("mock out the WriteFile method")
//			},
//		}
//
//		// use mockedWriter in code that requires Writer
//		// and then make assertions.
//
//	}
type WriterMock struct {
	// WriteFileFunc mocks the WriteFile method.
	WriteFileFunc func(file *File) error

	// calls tracks calls to the methods.
	calls struct {
		// WriteFile holds details about calls to the WriteFile method.
		WriteFile []struct {
			// File is the file argument value.
			File *File
		}
	}
	lockWriteFile sync.RWMutex
}

// WriteFile calls WriteFileFunc.
func (mock *WriterMock) WriteFile(file *File) error {
	callInfo := struct {
		File *File
	}{
		File: file,
	}
	mock.lockWriteFile.Lock()
	mock.calls.WriteFile = append(mock.calls.WriteFile, callInfo)
	mock.lockWriteFile.Unlock()
	if mock.WriteFileFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.WriteFileFunc(file)
}

// WriteFileCalls gets all the calls that were made to WriteFile.
// Check the length with:
//
//	len(mockedWriter.WriteFileCalls())
func (mock *WriterMock) WriteFileCalls() []struct {
	File *File
} {
	var calls []struct {
		File *File
	}
	mock.lockWriteFile.RLock()
	calls = mock.calls.WriteFile
	mock.lockWriteFile.RUnlock()
	return calls
}
